"""Tests demonstrating security vulnerabilities and secure alternatives."""

import pytest
import hmac
import secrets
import os


class TestTimingAttack:
    """Demonstrate timing attack vulnerability in string comparison."""

    def test_insecure_comparison(self):
        """Insecure comparison - vulnerable to timing attack."""
        secret = b"correct_secret_token"

        def insecure_compare(a, b):
            """INSECURE: Returns early on mismatch."""
            if len(a) != len(b):
                return False
            for x, y in zip(a, b):
                if x != y:
                    return False
            return True

        # These comparisons take different amounts of time
        assert insecure_compare(secret, secret) == True
        assert insecure_compare(secret, b"wrong_secret_token!") == False
        assert insecure_compare(secret, b"c") == False

    def test_secure_comparison(self):
        """Secure comparison using hmac.compare_digest."""
        secret = b"correct_secret_token"

        # Constant-time comparison - safe from timing attacks
        assert hmac.compare_digest(secret, secret) == True
        assert hmac.compare_digest(secret, b"wrong_secret_token!") == False


class TestWeakRandom:
    """Demonstrate weak vs strong random number generation."""

    def test_weak_random(self):
        """INSECURE: random module is predictable."""
        import random

        # Mersenne Twister can be predicted after observing outputs
        random.seed(12345)
        values = [random.randint(0, 100) for _ in range(10)]

        # Same seed produces same sequence - predictable!
        random.seed(12345)
        values2 = [random.randint(0, 100) for _ in range(10)]
        assert values == values2

    def test_secure_random(self):
        """SECURE: secrets module uses OS entropy."""
        # Cryptographically secure random
        token1 = secrets.token_hex(16)
        token2 = secrets.token_hex(16)

        # Each call produces unique, unpredictable value
        assert token1 != token2
        assert len(token1) == 32


class TestSQLInjection:
    """Demonstrate SQL injection vulnerability."""

    def test_vulnerable_query_building(self):
        """INSECURE: String formatting in SQL."""

        def build_query_insecure(username):
            # VULNERABLE: User input directly in query
            return f"SELECT * FROM users WHERE username = '{username}'"

        # Normal input
        query = build_query_insecure("alice")
        assert query == "SELECT * FROM users WHERE username = 'alice'"

        # Malicious input - SQL injection!
        malicious = "admin' OR '1'='1"
        query = build_query_insecure(malicious)
        # This would return ALL users!
        assert "OR '1'='1'" in query

    def test_parameterized_query(self):
        """SECURE: Parameterized queries prevent injection."""

        def build_query_secure(username):
            # Parameters are escaped by the database driver
            return ("SELECT * FROM users WHERE username = ?", (username,))

        query, params = build_query_secure("admin' OR '1'='1")
        # The malicious input is treated as a literal string
        assert params == ("admin' OR '1'='1",)


class TestCommandInjection:
    """Demonstrate command injection vulnerability."""

    def test_vulnerable_shell_command(self):
        """INSECURE: User input in shell command."""

        def build_command_insecure(filename):
            # VULNERABLE: Shell injection possible
            return f"cat {filename}"

        # Malicious input
        malicious = "file.txt; rm -rf /"
        cmd = build_command_insecure(malicious)
        # Would execute: cat file.txt; rm -rf /
        assert "; rm -rf /" in cmd

    def test_secure_command(self):
        """SECURE: Use argument list, not shell string."""
        import shlex

        def build_command_secure(filename):
            # Validate and use list of arguments
            if not filename.replace(".", "").replace("_", "").isalnum():
                raise ValueError("Invalid filename")
            return ["cat", filename]

        # Malicious input is rejected
        with pytest.raises(ValueError):
            build_command_secure("file.txt; rm -rf /")

        # Valid input works
        cmd = build_command_secure("file.txt")
        assert cmd == ["cat", "file.txt"]


class TestPickleVulnerability:
    """Demonstrate pickle deserialization vulnerability."""

    def test_pickle_code_execution(self):
        """INSECURE: Pickle can execute arbitrary code."""
        import pickle

        class MaliciousPayload:
            def __reduce__(self):
                # This would execute when unpickled!
                # return (os.system, ("echo HACKED",))
                # For safety, we just return a harmless function
                return (str, ("PAYLOAD_EXECUTED",))

        # Attacker creates malicious pickle
        malicious_data = pickle.dumps(MaliciousPayload())

        # Victim unpickles - code executes!
        result = pickle.loads(malicious_data)
        assert result == "PAYLOAD_EXECUTED"

    def test_safe_json(self):
        """SECURE: JSON cannot execute code."""
        import json

        data = {"user": "alice", "role": "admin"}
        serialized = json.dumps(data)
        deserialized = json.loads(serialized)

        assert deserialized == data
        # JSON only supports basic types - no code execution


class TestHardcodedSecrets:
    """Demonstrate hardcoded secrets vulnerability."""

    def test_environment_variables(self):
        """SECURE: Use environment variables for secrets."""
        # Set a test secret
        os.environ["TEST_API_KEY"] = "secret_key_123"

        # Read from environment
        api_key = os.environ.get("TEST_API_KEY")
        assert api_key == "secret_key_123"

        # Clean up
        del os.environ["TEST_API_KEY"]

        # Missing secret should be handled
        missing = os.environ.get("NONEXISTENT_KEY")
        assert missing is None


class TestAESModes:
    """Demonstrate AES mode vulnerabilities."""

    def test_ecb_mode_pattern_leak(self):
        """INSECURE: ECB mode leaks patterns in plaintext."""
        # ECB encrypts identical blocks to identical ciphertext
        # This reveals patterns in the data

        # Simulated ECB behavior (without actual crypto)
        def fake_ecb_encrypt(blocks):
            # Same input block -> same output (pattern leak!)
            block_map = {}
            result = []
            for i, block in enumerate(blocks):
                if block not in block_map:
                    block_map[block] = f"cipher_{i}"
                result.append(block_map[block])
            return result

        # Repeated plaintext blocks
        blocks = ["AAAA", "BBBB", "AAAA", "CCCC", "AAAA"]
        encrypted = fake_ecb_encrypt(blocks)

        # Pattern is visible! Same plaintext -> same ciphertext
        assert encrypted[0] == encrypted[2] == encrypted[4]

    def test_cbc_needs_authentication(self):
        """AES-CBC without authentication is vulnerable."""
        # CBC provides confidentiality but not integrity
        # Attacker can modify ciphertext without detection
        # This enables padding oracle attacks

        # AES-GCM provides both confidentiality AND integrity
        # Tampering is detected and rejected
        pass


class TestPasswordStorage:
    """Demonstrate password storage vulnerabilities."""

    def test_weak_hash(self):
        """INSECURE: MD5/SHA1 for passwords."""
        import hashlib

        password = "password123"

        # INSECURE: Fast hashes are easily brute-forced
        md5_hash = hashlib.md5(password.encode()).hexdigest()
        sha1_hash = hashlib.sha1(password.encode()).hexdigest()

        # These can be cracked in seconds with rainbow tables
        assert len(md5_hash) == 32
        assert len(sha1_hash) == 40

    def test_secure_password_hash(self):
        """SECURE: Use slow, salted password hashing."""
        # In production, use argon2-cffi or bcrypt
        # This is a simplified demonstration

        import hashlib

        password = "password123"
        salt = secrets.token_bytes(16)

        # PBKDF2 with high iteration count (still not ideal, use Argon2)
        hash_value = hashlib.pbkdf2_hmac(
            "sha256", password.encode(), salt, iterations=100000
        )

        assert len(hash_value) == 32
        assert len(salt) == 16
